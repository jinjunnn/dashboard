---
description: 
globs: 
alwaysApply: false
---
# åç«¯APIå¼€å‘è§„èŒƒ

## ğŸ—„ï¸ Supabaseé›†æˆ

### å®¢æˆ·ç«¯é…ç½®
```typescript
// src/lib/supabase/server.ts
import { createServerClient } from '@supabase/ssr'

export function createClient() {
  return createServerClient(
    process.env.SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}
```

### ç¯å¢ƒå˜é‡
```env
SUPABASE_URL=your_supabase_project_url
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key
```

## ğŸ“Š æ•°æ®è®¿é—®æ¨¡å¼

### ä¿¡å·æ•°æ®æŸ¥è¯¢

#### åŸºäºé…ç½®çš„ä¿¡å·æŸ¥è¯¢
```typescript
import { getSignalsByCategory, getSignalByName, signalTypeMapping } from '@/config/signals-config'

// è·å–äº¤æ˜“ä¿¡å·ï¼ˆåŸºäºé…ç½®ï¼‰
async function getSignals(category: 'intraday' | 'daily', signalName?: string) {
  const supabase = createClient()
  
  // è·å–è¯¥ç±»åˆ«ä¸‹çš„æ‰€æœ‰å¯ç”¨ä¿¡å·ç±»å‹
  const availableSignals = getSignalsByCategory(category)
  const validSignalTypes = availableSignals
    .filter(signal => signal.enabled)
    .map(signal => signal.name)
  
  let query = supabase
    .from('signals')
    .select(`
      id,
      symbol,
      signal_type,
      category,
      direction,
      price,
      confidence,
      status,
      created_at,
      expires_at,
      meta_data,
      stock:symbol (
        symbol,
        name,
        market
      )
    `)
    .eq('category', category)
    .eq('status', 'active')
    .in('signal_type', validSignalTypes)
    
  // å¦‚æœæŒ‡å®šäº†ä¿¡å·åç§°ï¼Œè¿›ä¸€æ­¥ç­›é€‰
  if (signalName) {
    const signalConfig = getSignalByName(signalName)
    if (signalConfig && signalConfig.enabled) {
      query = query.eq('signal_type', signalName)
    } else {
      throw new Error(`ä¿¡å·ç±»å‹ ${signalName} ä¸å­˜åœ¨æˆ–å·²ç¦ç”¨`)
    }
  }
  
  return query.order('created_at', { ascending: false })
}

// æ ¹æ®ä¿¡å·é…ç½®IDæŸ¥è¯¢
async function getSignalsByConfigId(configId: string) {
  const supabase = createClient()
  const signalConfig = getSignalConfigById(configId)
  
  if (!signalConfig || !signalConfig.enabled) {
    throw new Error(`ä¿¡å·é…ç½® ${configId} ä¸å­˜åœ¨æˆ–å·²ç¦ç”¨`)
  }
  
  return supabase
    .from('signals')
    .select('*')
    .eq('signal_type', signalConfig.name)
    .eq('category', signalConfig.category)
    .eq('status', 'active')
    .order('created_at', { ascending: false })
}

// è·å–ä¿¡å·ç»Ÿè®¡ä¿¡æ¯
async function getSignalStats(category: 'intraday' | 'daily') {
  const supabase = createClient()
  const availableSignals = getSignalsByCategory(category)
  
  const stats = await Promise.all(
    availableSignals.map(async (signalConfig) => {
      const { count } = await supabase
        .from('signals')
        .select('id', { count: 'exact' })
        .eq('signal_type', signalConfig.name)
        .eq('category', category)
        .eq('status', 'active')
        
      return {
        ...signalConfig,
        count: count || 0
      }
    })
  )
  
  return stats
}
```

### ç”¨æˆ·æ•°æ®ç®¡ç†
```typescript
// è·å–ç”¨æˆ·é…ç½®
async function getUserProfile(userId: string) {
  const supabase = createClient()
  
  return supabase
    .from('user_profiles')
    .select('*')
    .eq('id', userId)
    .single()
}

// æ›´æ–°ç”¨æˆ·è°ƒç”¨æ¬¡æ•°
async function updateUserCalls(userId: string, type: 'intraday' | 'daily') {
  const supabase = createClient()
  
  const field = type === 'intraday' ? 'intraday_calls_today' : 'daily_calls_today'
  
  return supabase.rpc('increment_user_calls', {
    user_id: userId,
    call_type: field
  })
}
```

## ğŸ” æƒé™ä¸å®‰å…¨

### Row Level Security (RLS)
```sql
-- ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„æ•°æ®
CREATE POLICY "Users can only access own data" ON user_profiles
FOR ALL USING (auth.uid() = id);

-- ä¿¡å·æ•°æ®å…¬å¼€åªè¯»
CREATE POLICY "Signals are publicly readable" ON signals
FOR SELECT USING (true);

-- æŸ¥è¯¢è®°å½•éœ€è¦è®¤è¯
CREATE POLICY "Authenticated users can insert queries" ON signal_queries
FOR INSERT WITH CHECK (auth.uid() = user_id);
```

### APIè®¿é—®æ§åˆ¶
```typescript
// æ£€æŸ¥ç”¨æˆ·æƒé™
async function checkUserPermission(userId: string, action: string) {
  const profile = await getUserProfile(userId)
  
  if (!profile) {
    throw new Error('ç”¨æˆ·ä¸å­˜åœ¨')
  }
  
  // æ£€æŸ¥è°ƒç”¨æ¬¡æ•°é™åˆ¶
  const limits = {
    free: { intraday: 10, daily: 5 },
    pro: { intraday: 100, daily: 50 },
    premium: { intraday: -1, daily: -1 } // æ— é™åˆ¶
  }
  
  const userLimit = limits[profile.tier as keyof typeof limits]
  // å®ç°é™åˆ¶æ£€æŸ¥é€»è¾‘
}
```

## ğŸ“ˆ æ•°æ®å¤„ç†

### ä¿¡å·æ•°æ®ç»“æ„
```typescript
interface Signal {
  id: number
  symbol: string
  signal_type: 'BOS' | 'MSS' | 'FVG' | 'SSL' | 'OB'
  category: 'intraday' | 'daily'
  direction: 'BULLISH' | 'BEARISH'
  price: number
  confidence: number // 0-100
  status: 'active' | 'expired' | 'triggered'
  created_at: string
  expires_at: string
  meta_data: Record<string, any>
  backtest?: {
    success_rate: number
    avg_return: number
    max_drawdown: number
  }
}
```

### æ•°æ®éªŒè¯
```typescript
import { z } from 'zod'

const SignalSchema = z.object({
  symbol: z.string().min(1),
  signal_type: z.enum(['BOS', 'MSS', 'FVG', 'SSL', 'OB']),
  category: z.enum(['intraday', 'daily']),
  direction: z.enum(['BULLISH', 'BEARISH']),
  price: z.number().positive(),
  confidence: z.number().min(0).max(100)
})

// ä½¿ç”¨éªŒè¯
function validateSignal(data: unknown) {
  return SignalSchema.parse(data)
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### æŸ¥è¯¢ä¼˜åŒ–
- ä½¿ç”¨é€‚å½“çš„ç´¢å¼•
- é™åˆ¶è¿”å›å­—æ®µ (`select` æŒ‡å®šå­—æ®µ)
- å®ç°åˆ†é¡µåŠ è½½
- ç¼“å­˜é¢‘ç¹æŸ¥è¯¢çš„ç»“æœ

### è¿æ¥æ± ç®¡ç†
```typescript
// ä½¿ç”¨è¿æ¥æ± é¿å…è¿æ¥æ³„æ¼
const supabase = createClient()

// ç¡®ä¿åœ¨é€‚å½“æ—¶æœºæ¸…ç†è¿æ¥
process.on('exit', () => {
  // æ¸…ç†èµ„æº
})
```

## ğŸ”§ é”™è¯¯å¤„ç†

### ç»Ÿä¸€é”™è¯¯å“åº”
```typescript
interface ApiError {
  code: string
  message: string
  details?: any
}

function handleSupabaseError(error: any): ApiError {
  switch (error.code) {
    case 'PGRST116':
      return {
        code: 'NOT_FOUND',
        message: 'è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨'
      }
    case '42501':
      return {
        code: 'PERMISSION_DENIED',
        message: 'æƒé™ä¸è¶³'
      }
    default:
      return {
        code: 'UNKNOWN_ERROR',
        message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'
      }
  }
}
```

### é‡è¯•æœºåˆ¶
```typescript
async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries = 3
): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation()
    } catch (error) {
      if (i === maxRetries - 1) throw error
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)))
    }
  }
  throw new Error('æ“ä½œå¤±è´¥')
}
```
