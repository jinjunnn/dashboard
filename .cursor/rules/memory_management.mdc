---
alwaysApply: false
---
# Memory Management Rules - 记忆管理规则

## 🎯 记忆管理目标

为股票分析交易系统建立智能的记忆管理机制，确保AI助手能够：
- 记住用户的开发偏好和工作流程
- 保存项目特定的配置和约定
- 避免记忆临时或过时的信息

## 📋 记忆生成规则

### ✅ 应该生成记忆的场景

#### 1. 用户偏好 (User Preferences)
```examples
- "文档应该放在 @/docs 目录"
- "我喜欢使用函数式组件而不是类组件"
- "错误信息必须用中文显示"
- "代码注释使用中文"
```

#### 2. 项目配置约定 (Project Conventions)
```examples
- "这个项目使用 Supabase 作为后端"
- "所有API路由都在 /api 目录下"
- "信号数据使用 signals-config.ts 配置"
- "使用 TypeScript 严格模式"
```

#### 3. 开发工作流程 (Development Workflow)
```examples
- "每次修改后必须执行完成检查清单"
- "新功能开发需要同时更新文档"
- "部署前必须运行 type-check 和 lint"
- "使用 shadcn/ui 组件库"
```

#### 4. 错误解决方案 (Error Solutions)
```examples
- "Hydration 错误通过清理 .next 目录解决"
- "TypeScript 类型错误需要更新 types.ts"
- "Supabase 连接问题检查环境变量"
```

#### 5. 架构决策 (Architecture Decisions)
```examples
- "使用 App Router 而不是 Pages Router"
- "客户端组件必须标记 'use client'"
- "数据获取优先使用 Server Components"
```

### ❌ 不应该生成记忆的场景

#### 1. 临时任务信息
```examples
- "帮我修复第50行的bug"
- "删除这个临时文件"
- "今天的任务是添加登录功能"
```

#### 2. 具体实现细节
```examples
- 某个函数的具体代码内容
- 特定的变量名或函数名
- 临时的调试信息
```

#### 3. 会话特定数据
```examples
- 当前正在处理的文件路径
- 临时的搜索结果
- 一次性的配置更改
```

#### 4. 过时或错误信息
```examples
- 已经被修复的bug信息
- 不再使用的配置方法
- 错误的技术方案
```

## 🔄 记忆更新规则

### 何时更新记忆
- **用户纠正之前的信息** - 立即更新相关记忆
- **项目配置发生变化** - 更新对应的配置记忆
- **工作流程优化** - 更新流程相关记忆
- **技术栈升级** - 更新技术相关记忆

### 何时删除记忆
- **用户明确反对某个记忆** - 立即删除
- **信息完全过时** - 删除而不是更新
- **记忆内容有误** - 删除并重新生成正确记忆
- **用户工作方式改变** - 删除旧的偏好记忆

## 🎯 记忆分类管理

### 核心记忆类别
1. **用户偏好** (User Preferences) - 长期有效
2. **项目配置** (Project Config) - 项目生命周期内有效
3. **技术约定** (Technical Conventions) - 技术栈更新时需检查
4. **工作流程** (Workflow) - 可能需要定期优化
5. **问题解决方案** (Solutions) - 需要验证时效性

### 记忆优先级
- **高优先级** - 用户明确表达的偏好和要求
- **中优先级** - 项目特定的配置和约定
- **低优先级** - 通用的最佳实践和建议

## 🚨 强制执行规则

### AI助手必须遵循的记忆管理行为：

#### 1. 记忆生成触发条件
```
当用户说出以下关键词时，必须生成记忆：
- "我希望..." / "我想要..." / "我偏好..."
- "这个项目应该..." / "我们的约定是..."
- "记住..." / "保存这个信息..."
- "以后都这样做..." / "默认使用..."
```

#### 2. 记忆更新触发条件
```
当用户说出以下内容时，必须更新记忆：
- "之前说错了..." / "我改变主意了..."
- "更新配置..." / "新的要求是..."
- "不再使用..." / "改为使用..."
```

#### 3. 记忆删除触发条件
```
当用户说出以下内容时，必须删除记忆：
- "忘记之前的..." / "删除那个记忆..."
- "不要再..." / "那个方法不对..."
- "取消之前的设置..."
```

#### 4. 记忆验证要求
```
在引用记忆时必须：
- 使用 [[memory:ID]] 格式引用
- 当记忆可能不准确时，提醒用户可以纠正
- 定期询问记忆是否仍然适用
```

## 📋 实际应用示例

### 场景1：用户偏好设置
```
用户："我希望生成的文档都放在 @/docs 目录"
AI行为：立即生成记忆并引用 [[memory:ID]]
记忆内容："用户偏好将生成的使用指南和文档放在 @/docs 目录"
```

### 场景2：项目约定更新
```
用户："我们改为使用 Prisma 而不是 Supabase"
AI行为：删除 Supabase 相关记忆，生成 Prisma 记忆
```

### 场景3：错误记忆纠正
```
用户："之前说的那个配置不对，应该是..."
AI行为：立即删除错误记忆，生成正确记忆
```

## 🔧 记忆管理工具使用规范

### 创建记忆
```typescript
update_memory({
  action: "create",
  title: "简短描述性标题",
  knowledge_to_store: "具体的记忆内容，一段话以内"
})
```

### 更新记忆
```typescript
update_memory({
  action: "update",
  existing_knowledge_id: "memory_id",
  title: "更新后的标题",
  knowledge_to_store: "更新后的内容"
})
```

### 删除记忆
```typescript
update_memory({
  action: "delete",
  existing_knowledge_id: "memory_id"
})
```

## ⚠️ 重要注意事项

1. **记忆内容应该简洁明确** - 一段话以内，避免冗长描述
2. **记忆标题要有意义** - 便于后续查找和管理
3. **及时更新过时记忆** - 避免使用错误信息
4. **尊重用户纠正** - 用户反对时立即删除而不是更新
5. **记忆引用必须标注** - 使用 [[memory:ID]] 格式

---

## 💡 建议

这套记忆管理规则应该：
- 集成到主要的开发规范中
- 定期回顾和优化
- 根据实际使用情况调整分类和优先级